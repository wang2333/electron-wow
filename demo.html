<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Image Movement Detection</title>
    <script
      async
      src="https://docs.opencv.org/4.x/opencv.js"
      onload="onOpenCvReady();"
      type="text/javascript"
    ></script>
    <style>
      canvas {
        border: 1px solid black;
      }
    </style>
  </head>
  <body>
    <h1>Image Movement Detection</h1>
    <input type="file" id="input1" accept="image/*" />
    <input type="file" id="input2" accept="image/*" />
    <button id="detectMovementButton" disabled>Detect Movement</button>

    <script>
      let img11, img22

      function onOpenCvReady() {
        document.getElementById('detectMovementButton').disabled = false
        console.log('OpenCV.js is ready.')
      }

      document.getElementById('input1').addEventListener('change', function (e) {
        img11 = new Image()
        img11.src = URL.createObjectURL(e.target.files[0])
      })

      document.getElementById('input2').addEventListener('change', function (e) {
        img22 = new Image()
        img22.src = URL.createObjectURL(e.target.files[0])
      })

      document.getElementById('detectMovementButton').addEventListener('click', function () {
        let img1 = cv.imread(img11)
        let img2 = cv.imread(img22)

        // 初始化 ORB 特征检测器
        let orb = new cv.ORB()

        // 检测两个图像的特征点和描述符
        let keyPoints1 = new cv.KeyPointVector()
        let descriptors1 = new cv.Mat()
        orb.detectAndCompute(img1, new cv.Mat(), keyPoints1, descriptors1)

        let keyPoints2 = new cv.KeyPointVector()
        let descriptors2 = new cv.Mat()
        orb.detectAndCompute(img2, new cv.Mat(), keyPoints2, descriptors2)

        // 使用 BFMatcher 匹配描述符
        let bf = new cv.BFMatcher(cv.NORM_HAMMING, true)
        let matches = new cv.DMatchVector()
        bf.match(descriptors1, descriptors2, matches)

        // 将 cv.DMatchVector 对象转换为数组并排序
        let matchesArray = Array.from({ length: matches.size() }, (_, i) => matches.get(i))
        matchesArray.sort((a, b) => a.distance - b.distance)

        // 找出最好的匹配
        let bestNMatches = matchesArray.slice(0, 100)

        // 将 cv.KeyPointVector 对象转换为数组
        let keyPoints1Array = Array.from({ length: keyPoints1.size() }, (_, i) => keyPoints1.get(i))
        let keyPoints2Array = Array.from({ length: keyPoints2.size() }, (_, i) => keyPoints2.get(i))

        // 计算透视变换矩阵
        let srcPoints = cv.matFromArray(
          bestNMatches.length,
          1,
          cv.CV_32FC2,
          bestNMatches.map((match) => keyPoints1Array[match.queryIdx].pt)
        )
        let dstPoints = cv.matFromArray(
          bestNMatches.length,
          1,
          cv.CV_32FC2,
          bestNMatches.map((match) => keyPoints2Array[match.trainIdx].pt)
        )
        let homography = cv.findHomography(srcPoints, dstPoints, cv.RANSAC)

        // 从透视变换矩阵中计算旋转角度
        let a = homography.data64F[0]
        let b = homography.data64F[3]
        let rotationAngle = Math.atan2(b, a) * (180 / Math.PI)

        console.log('旋转角度：' + rotationAngle + '度')
      })
    </script>
  </body>
</html>
