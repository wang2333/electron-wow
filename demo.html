<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Image Movement Detection</title>
    <script
      async
      src="https://docs.opencv.org/4.x/opencv.js"
      onload="onOpenCvReady();"
      type="text/javascript"
    ></script>
    <style>
      canvas {
        border: 1px solid black;
      }
    </style>
  </head>
  <body>
    <h1>Image Movement Detection</h1>
    <input type="file" id="input1" accept="image/*" />
    <input type="file" id="input2" accept="image/*" />
    <button id="detectMovementButton" disabled>Detect Movement</button>
    <p>Angle: <span id="angle"></span> degrees</p>
    <p>Distance: <span id="distance"></span> pixels</p>
    <canvas id="canvasOutput" width="153" height="153"></canvas>

    <script>
      let img1, img2

      function onOpenCvReady() {
        document.getElementById('detectMovementButton').disabled = false
        console.log('OpenCV.js is ready.')
      }

      document.getElementById('input1').addEventListener('change', function (e) {
        img1 = new Image()
        img1.src = URL.createObjectURL(e.target.files[0])
      })

      document.getElementById('input2').addEventListener('change', function (e) {
        img2 = new Image()
        img2.src = URL.createObjectURL(e.target.files[0])
      })

      document.getElementById('detectMovementButton').addEventListener('click', function () {
        let currentScreenshot = cv.imread(img1)
        let previousScreenshot = cv.imread(img2)

        console.time()
        let movement = detectMovement(currentScreenshot, previousScreenshot)
        console.timeEnd()
        console.log('ðŸ‘» ~ movement:', movement)
        if (Math.hypot(movement.x, movement.y) > 0.5) {
          // Draw the movement direction line
          let centerX = currentScreenshot.cols / 2
          let centerY = currentScreenshot.rows / 2
          let endX = centerX - movement.x
          let endY = centerY - movement.y
          cv.line(
            currentScreenshot,
            new cv.Point(centerX, centerY),
            new cv.Point(endX, endY),
            new cv.Scalar(255, 255, 255),
            2
          )
          cv.imshow('canvasOutput', currentScreenshot)
          // const distanc = Math.sqrt(Math.pow(centerX - endX, 2) + Math.pow(centerY - endY, 2))
          const distanc = Math.sqrt(movement.x * movement.x + movement.y * movement.y)
          console.log('ðŸ‘» ~ distanc:', distanc)
          let angle = Math.atan2(movement.y, movement.x) * (180 / Math.PI) // Convert to degrees
          console.log('ðŸ‘» ~ angle:', angle)
        }
      })

      function detectMovement(currentScreenshot, previousScreenshot) {
        // Convert to grayscale
        let grayCurrent = new cv.Mat()
        let grayPrevious = new cv.Mat()
        cv.cvtColor(currentScreenshot, grayCurrent, cv.COLOR_BGR2GRAY)
        cv.cvtColor(previousScreenshot, grayPrevious, cv.COLOR_BGR2GRAY)
        // Create ORB object
        let orb = new cv.ORB(5000)

        // Detect ORB keypoints and descriptors
        let keypoints1 = new cv.KeyPointVector()
        let keypoints2 = new cv.KeyPointVector()
        let descriptors1 = new cv.Mat()
        let descriptors2 = new cv.Mat()
        orb.detectAndCompute(grayPrevious, new cv.Mat(), keypoints1, descriptors1)
        orb.detectAndCompute(grayCurrent, new cv.Mat(), keypoints2, descriptors2)

        // Check if descriptors are empty
        if (descriptors1.rows === 0 || descriptors2.rows === 0) {
          return new cv.Point(0, 0)
        }

        // Use BFMatcher for feature matching
        let bf = new cv.BFMatcher(cv.NORM_HAMMING, false)
        let matches = new cv.DMatchVectorVector()
        bf.knnMatch(descriptors1, descriptors2, matches, 2)

        // Apply Lowe's ratio test
        let goodMatches = []
        for (let i = 0; i < matches.size(); i++) {
          let m = matches.get(i).get(0)
          let n = matches.get(i).get(1)
          if (m.distance < 0.9 * n.distance) {
            goodMatches.push(m)
          }
        }
        console.log('ðŸ‘» ~ goodMatches:', goodMatches)

        // If there are enough good matches, calculate displacement vector
        if (goodMatches.length > 5) {
          let pts1 = []
          let pts2 = []
          for (let i = 0; i < goodMatches.length; i++) {
            pts1.push(keypoints1.get(goodMatches[i].queryIdx).pt)
            pts2.push(keypoints2.get(goodMatches[i].trainIdx).pt)
          }

          let pts1Mat = cv.matFromArray(
            pts1.length,
            1,
            cv.CV_32FC2,
            [].concat(...pts1.map((p) => [p.x, p.y]))
          )
          let pts2Mat = cv.matFromArray(
            pts2.length,
            1,
            cv.CV_32FC2,
            [].concat(...pts2.map((p) => [p.x, p.y]))
          )

          let mask = new cv.Mat()
          let M = cv.findHomography(pts1Mat, pts2Mat, cv.RANSAC, 5.0, mask)
          let matchesMask = mask.data

          // Calculate movement only for inliers
          let inlierPts1 = []
          let inlierPts2 = []
          for (let i = 0; i < matchesMask.length; i++) {
            if (matchesMask[i]) {
              inlierPts1.push(pts1[i])
              inlierPts2.push(pts2[i])
            }
          }

          if (inlierPts1.length > 0) {
            let movementX = 0
            let movementY = 0
            for (let i = 0; i < inlierPts1.length; i++) {
              movementX += inlierPts2[i].x - inlierPts1[i].x
              movementY += inlierPts2[i].y - inlierPts1[i].y
            }

            // // Calculate distance and angle
            // let distance = Math.sqrt(movementX * movementX + movementY * movementY)
            // console.log('ðŸ‘» ~ distance:', distance)
            // let angle = Math.atan2(movementY, movementX) * (180 / Math.PI) // Convert to degrees
            // console.log('ðŸ‘» ~ angle:', angle)

            return new cv.Point(movementX / inlierPts1.length, movementY / inlierPts1.length)
          } else {
            return new cv.Point(0, 0)
          }
        } else {
          return new cv.Point(0, 0)
        }
      }

      // Cleanup
      // currentScreenshot.delete()
      // previousScreenshot.delete()
    </script>
  </body>
</html>
